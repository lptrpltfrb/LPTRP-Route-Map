<!DOCTYPE html>
<html>
<head>
  <title>LPTRP Routes Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <div id="map"></div>
  <script>
    const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRyCBsc0sCJs7FXH1Q1XEiCuMrV_ckVg9tcMvozYThFJfqpcOPdlo6YqxBYf6I1zHO0-yQZ_vz3knSS/pub?gid=1233383270&single=true&output=csv";

    const map = L.map('map').setView([12.8797, 121.7740], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    function parseCSV(csvText) {
      const lines = csvText.split(/\r?\n/).filter(l => l.trim() !== '');
      if (lines.length < 3) {
        console.warn("CSV too short, check if data starts at row 3");
        return [];
      }

      const headers = lines[1].split(',').map(h => h.trim()); // Use row 2 as header
      const geoIndex = headers.indexOf("GEO PATH");

      if (geoIndex === -1) {
        console.error("GEO PATH column not found in headers:", headers);
        return [];
      }

      const routes = [];
      let emptyCount = 0;
      let validCount = 0;
      let invalidCount = 0;

      for (let i = 2; i < lines.length; i++) { // Start from row 3
        const row = lines[i].split(',').map(cell => cell.trim());
        const rawGeo = row[geoIndex];

        if (!rawGeo) {
          emptyCount++;
          console.warn(`âš ï¸ GEO PATH is empty at row ${i + 1}`);
          continue;
        }

        try {
          const path = JSON.parse(rawGeo);
          if (Array.isArray(path) && path.every(p => Array.isArray(p) && p.length === 2)) {
            routes.push(path);
            validCount++;
          } else {
            invalidCount++;
            console.warn(`âš ï¸ Invalid GEO PATH format at row ${i + 1}:`, rawGeo);
          }
        } catch (e) {
          invalidCount++;
          console.warn(`âš ï¸ Invalid GEO PATH JSON at row ${i + 1}:`, rawGeo);
        }
      }

      console.info(`ðŸ“Š Rows processed: ${lines.length - 2}`);
      console.info(`ðŸŸ¢ Valid geo paths: ${validCount}`);
      console.info(`âš ï¸ Empty GEO PATH rows: ${emptyCount}`);
      console.info(`âš ï¸ Invalid GEO PATH rows: ${invalidCount}`);

      return routes;
    }

    async function loadRoutes() {
      try {
        const res = await fetch(csvUrl);
        const text = await res.text();
        const geoPaths = parseCSV(text);

        if (geoPaths.length === 0) {
          console.warn("No valid routes found.");
          return;
        }

        geoPaths.forEach(path => {
          L.polyline(path.map(([lng, lat]) => [lat, lng]), {
            color: 'blue',
            weight: 3
          }).addTo(map);
        });

        map.fitBounds(geoPaths.flat().map(([lng, lat]) => [lat, lng]));
      } catch (err) {
        console.error("Failed to load CSV:", err);
      }
    }

    loadRoutes();
  </script>
</body>
</html>
